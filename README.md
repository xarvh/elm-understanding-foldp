
**IMPORTANT**
With the release of Elm 0.17, this guide is now obsolete.
Read http://elm-lang.org/blog/farewell-to-frp


Understanding Elm Signals and Signal.foldp
==========================================

Elm's [start-app](https://github.com/evancz/start-app) package makes it easier for newbies to start writing Elm apps without too much hassle.

The next step in my learning was to find out what `StartApp.Simple` was doing under the hood: the ambition of this short guide is to show that it's not complicated at all, and to help newcomers around a couple of the stumbling blocks I found.

I will assume that you already understand the [Elm syntax](http://elm-lang.org/docs/syntax) and went through the [Elm Architecture tutorial](https://github.com/evancz/elm-architecture-tutorial/) until at least example 5.

Let's dive right in.

The Mailbox
-----------
```elm
type Action
  = AddCoconut
  | RemoveCoconut

actionsMailbox : Signal.Mailbox Action
actionsMailbox =
  Signal.mailbox RemoveCoconut
```
You can think about a mailbox as the [Dispatcher](https://facebook.github.io/flux/docs/overview.html#a-single-dispatcher) of [Flux](https://facebook.github.io/flux/) architectures.
Its task is to collect all triggered actions and ensure that they are executed in the correct order.
Of course, there are other use cases for a mailbox, but this is how it is used for the Elm Architecture.

A mailbox has an `address` and a `signal` field.
`mailbox.address` is the mailbox input pipe: for example, mouse clicks and incoming ports push their events there.
`mailbox.signal` is the mailbox output pipe.


Signals
-------
You might have noticed that in order to create a Mailbox, we need to specify a _default value_, which in the example above was the `Action` `RemoveCoconut`.
In the Elm Architecture, this value is ignored: you can put any value of the right type and it won't make a difference.
So why is it there?

Thing is, a `Signal` _always_ needs to have a valid value, because it is defined as ["a value that changes over time"](http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Signal).
This was a huge source of confusion for me, because "a value that changes over time" is not really how it is used in the Elm Architecture.
In the Elm Architecture, a `Signal` is used as _something that can trigger_, ie, a source of _events_, which is why the default value is completely ignored.

So when the mailbox receives something, such as an action from a mouse click, its signal will _trigger_.


Signal.foldp
------------
`Signal.foldp` is the heart of the Elm Architecture and discrete [functional reactive programming](https://en.wikipedia.org/wiki/Functional_reactive_programming).

```elm
type alias Model = ...

initialModel : Model
initialModel = ...


update : Action -> Model -> Model
update action model = ...


modelSignal : Signal.Signal Model
modelSignal =
  Signal.foldp update initialModel actionsMailbox.signal
```

Every time `actionsMailbox.signal` triggers, `Signal.foldp` feeds the triggered `Action` and the last version of the model to the `update` function, producing a new version of the model.
The output of `Signal.foldp` is thus a `Model` that can change in time, that is, a `Signal.Signal Model`.

What `Signal.foldp` does is to _transform a signal of actions in a signal of models_, `modelSignal` in the example above.


main
----
In `Elm`, `main` must be assigned a value that describes the _view_ to be rendered to the user, either an [Element](http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Graphics-Element) or some [HTML](http://package.elm-lang.org/packages/evancz/elm-html/4.0.2/Html) object; if this view can change with time, then it will need to be a Signal:

```elm
view : Signal.Address Action -> Model -> Html
view address model =
  Html.div
    [ Html.button [Html.Events.onClick address AddCoconut] [ Html.text "Start timer!" ]
    , ...
    , ...
    ]

main : Signal.Signal Html.Html
main =
  Signal.map (view actionsMailbox.address) modelSignal
```

Once more, we are transforming a Signal into another: this time we are transforming the signal of models, `modelSignal`, into a signal of html, `main`.
Whenever `modelSignal` triggers, `main` triggers as well, in turn causing the app to re-render.

Incidentally, `view` is also one of the possible sources of events (for example the click events `Html.Events.click`); this is why `view` needs to know the address of our `actionsMailbox`: so that the Actions generated by the user clicks are dispatched as a Signal to `Signal.foldp`.


Putting all together
--------------------
```elm
--
-- Model, Update, View
--
type Action
  = AddCoconut
  | RemoveCoconut


type alias Model = ...

initialModel : Model
initialModel = ...


update : Action -> Model -> Model
update action model = ...


view : Signal.Address Action -> Model -> Html
view address model =
  Html.div
    [ Html.button [Html.Events.onClick address AddCoconut] [ Html.text "Add a coconut!" ]
    , ...
    , ...
    ]


--
-- Main (this is the part that StartApp.Simple does for you)
--
actionsMailbox : Signal.Mailbox Action
actionsMailbox =
  Signal.mailbox RemoveCoconut


modelSignal : Signal.Signal Model
modelSignal =
  Signal.foldp update initialModel actionsMailbox.signal


main : Signal.Signal Html.Html
main =
  Signal.map (view actionsMailbox.address) modelSignal
```

The last block is pretty much what is happening inside `StartApp.Simple`: whenever a user clicks on "Add a coconut!" button, this is what happens:

1. The view sends `AddCoconut` to `actionsMailbox.address`
1. `actionsMailbox.signal` triggers with `AddCoconut`
1. `Signal.foldp` executes `update`, triggering with the new model
1. `main` executes `view`, triggering with the new html object
1. The app re-renders


Backmatter
----------
Please let me know of any way of improving this guide by [openening an issue](https://github.com/xarvh/elm-understanding-foldp/issues) or [creating a pull request](https://github.com/xarvh/elm-understanding-foldp/pulls).
